// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: idmap_common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_idmap_5fcommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_idmap_5fcommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_idmap_5fcommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_idmap_5fcommon_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_idmap_5fcommon_2eproto;
namespace idmap {
class Gnss;
struct GnssDefaultTypeInternal;
extern GnssDefaultTypeInternal _Gnss_default_instance_;
class IDMapStatus;
struct IDMapStatusDefaultTypeInternal;
extern IDMapStatusDefaultTypeInternal _IDMapStatus_default_instance_;
class LaneAttribute;
struct LaneAttributeDefaultTypeInternal;
extern LaneAttributeDefaultTypeInternal _LaneAttribute_default_instance_;
class LaneNode;
struct LaneNodeDefaultTypeInternal;
extern LaneNodeDefaultTypeInternal _LaneNode_default_instance_;
class NotODD;
struct NotODDDefaultTypeInternal;
extern NotODDDefaultTypeInternal _NotODD_default_instance_;
class Zlevel;
struct ZlevelDefaultTypeInternal;
extern ZlevelDefaultTypeInternal _Zlevel_default_instance_;
}  // namespace idmap
PROTOBUF_NAMESPACE_OPEN
template<> ::idmap::Gnss* Arena::CreateMaybeMessage<::idmap::Gnss>(Arena*);
template<> ::idmap::IDMapStatus* Arena::CreateMaybeMessage<::idmap::IDMapStatus>(Arena*);
template<> ::idmap::LaneAttribute* Arena::CreateMaybeMessage<::idmap::LaneAttribute>(Arena*);
template<> ::idmap::LaneNode* Arena::CreateMaybeMessage<::idmap::LaneNode>(Arena*);
template<> ::idmap::NotODD* Arena::CreateMaybeMessage<::idmap::NotODD>(Arena*);
template<> ::idmap::Zlevel* Arena::CreateMaybeMessage<::idmap::Zlevel>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace idmap {

enum MapDataSource : int {
  kMapDSUnknown = 0,
  kMapDSChangan = 1,
  kMapDSNavInfo = 2,
  kMapDSTencent = 3,
  kMapDSAutoNavi = 4,
  kMapDSBaidu = 5,
  kMapDSLeador = 6,
  kMapDSOthers = 99,
  MapDataSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MapDataSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MapDataSource_IsValid(int value);
constexpr MapDataSource MapDataSource_MIN = kMapDSUnknown;
constexpr MapDataSource MapDataSource_MAX = kMapDSOthers;
constexpr int MapDataSource_ARRAYSIZE = MapDataSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MapDataSource_descriptor();
template<typename T>
inline const std::string& MapDataSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MapDataSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MapDataSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MapDataSource_descriptor(), enum_t_value);
}
inline bool MapDataSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MapDataSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MapDataSource>(
    MapDataSource_descriptor(), name, value);
}
enum LineType : int {
  kLineTNone = 0,
  kLineTDiversionArea = 1,
  kLineTDistanceConfirmation = 2,
  kLineTDeceleration = 3,
  kLineTNoParkingArea = 4,
  kLineTSlotLine = 5,
  kLineTOther = 99,
  LineType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LineType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LineType_IsValid(int value);
constexpr LineType LineType_MIN = kLineTNone;
constexpr LineType LineType_MAX = kLineTOther;
constexpr int LineType_ARRAYSIZE = LineType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LineType_descriptor();
template<typename T>
inline const std::string& LineType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LineType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LineType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LineType_descriptor(), enum_t_value);
}
inline bool LineType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LineType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LineType>(
    LineType_descriptor(), name, value);
}
enum LineMarkingType : int {
  kLMTNone = 0,
  kLMTUnknown = 1,
  kLMTSolidLine = 2,
  kLMTDashedLine = 3,
  kLMTDoubleSolidLine = 4,
  kLMTDoubleDashedLine = 5,
  kLMTLeftSolidRightDashed = 6,
  kLMTRightSolidLeftDashed = 7,
  kLMTDashedBlocks = 8,
  kLMTFourSolidLine = 9,
  kLMTVirtual = 10,
  kLMTOther = 99,
  LineMarkingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LineMarkingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LineMarkingType_IsValid(int value);
constexpr LineMarkingType LineMarkingType_MIN = kLMTNone;
constexpr LineMarkingType LineMarkingType_MAX = kLMTOther;
constexpr int LineMarkingType_ARRAYSIZE = LineMarkingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LineMarkingType_descriptor();
template<typename T>
inline const std::string& LineMarkingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LineMarkingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LineMarkingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LineMarkingType_descriptor(), enum_t_value);
}
inline bool LineMarkingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LineMarkingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LineMarkingType>(
    LineMarkingType_descriptor(), name, value);
}
enum Color : int {
  kUnknown = 0,
  kWhite = 1,
  kYellow = 2,
  kOrange = 3,
  kRed = 4,
  kBlue = 5,
  kGreen = 6,
  kLeftYellowRightWhite = 7,
  kLeftWhiteRightYellow = 8,
  kOther = 99,
  Color_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Color_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Color_IsValid(int value);
constexpr Color Color_MIN = kUnknown;
constexpr Color Color_MAX = kOther;
constexpr int Color_ARRAYSIZE = Color_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Color_descriptor();
template<typename T>
inline const std::string& Color_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Color>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Color_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Color_descriptor(), enum_t_value);
}
inline bool Color_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Color* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Color>(
    Color_descriptor(), name, value);
}
enum RoadBoundaryType : int {
  kRoadBTNone = 0,
  kRoadBTGuardrail = 1,
  kRoadBTCurb = 2,
  kRoadBTGeographical = 3,
  kRoadBTGreenbelt = 4,
  kRoadBTCarParkColumn = 5,
  kRoadBTWall = 6,
  kRoadBTOtherHardIsolation = 7,
  kRoadBTOther = 99,
  RoadBoundaryType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RoadBoundaryType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RoadBoundaryType_IsValid(int value);
constexpr RoadBoundaryType RoadBoundaryType_MIN = kRoadBTNone;
constexpr RoadBoundaryType RoadBoundaryType_MAX = kRoadBTOther;
constexpr int RoadBoundaryType_ARRAYSIZE = RoadBoundaryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoadBoundaryType_descriptor();
template<typename T>
inline const std::string& RoadBoundaryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoadBoundaryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoadBoundaryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RoadBoundaryType_descriptor(), enum_t_value);
}
inline bool RoadBoundaryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RoadBoundaryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RoadBoundaryType>(
    RoadBoundaryType_descriptor(), name, value);
}
enum SignType : int {
  kSignTUnknown = 0,
  kSignTSteepDropRight = 1,
  kSignTSteepDropLeft = 2,
  kSignTVillage = 3,
  kSignTRiverBankRight = 4,
  kSignTRiverBankLeft = 5,
  kSignTTShapedLevelCrossing = 6,
  kSignTFerryTerminal = 7,
  kSignTCarriageWayNarrows = 8,
  kSignTFallingRocksLeft = 9,
  kSignTLeftBend = 10,
  kSignTRightBend = 11,
  kSignTRoadFloods = 12,
  kSignTIntersection = 13,
  kSignTIntersectionWithMinorRoad = 14,
  kSignTYShapedIntersectionLowerLeft = 15,
  kSignTYShapedIntersectionLowerRight = 16,
  kSignTYShapedIntersectionUpperLeft = 17,
  kSignTCarriageWayNarrowsLeft = 18,
  kSignTYShapedIntersectionUpperRight = 19,
  kSignTTJunction = 20,
  kSignTTJunctionLeft = 21,
  kSignTTJunctionRight = 22,
  kSignTRoundabout = 23,
  kSignTSeriesCurves = 24,
  kSignTContinuousDownhill = 25,
  kSignTUnevenRoad = 26,
  kSignTRainOrSnow = 27,
  kSignTDip = 28,
  kSignTHump = 29,
  kSignTSlow = 30,
  kSignTSteepAscent = 31,
  kSignTBuiltUpArea = 32,
  kSignTCrossLevelCrossing = 33,
  kSignTHighAccidentArea = 34,
  kSignTTwoWayTraffic = 35,
  kSignTWildAnimalsCrossing = 36,
  kSignTTunnel = 37,
  kSignTTunnelLights = 38,
  kSignTHumpbackBridge = 39,
  kSignTRailwayCrossingWithoutGates = 40,
  kSignTSteepDescent = 41,
  kSignTRightCurve = 42,
  kSignTLeftCurve = 43,
  kSignTSlipperyRoad = 44,
  kSignTLightSignals = 45,
  kSignTRailwayCrossingWithGates = 46,
  kSignTCarriageWayNarrowsRight = 47,
  kSignTRightSideDetour = 48,
  kSignTNarrowBridge = 49,
  kSignTMaintainSafeDistance = 50,
  kSignTBadWeather = 51,
  kSignTDisabled = 52,
  kSignTTidalLane = 53,
  kSignTFog = 54,
  kSignTChildren = 55,
  kSignTCyclists = 56,
  kSignTRoadWorks = 57,
  kSignTLaneMergeLeft = 58,
  kSignTLaneMergeRight = 59,
  kSignTSideWinds = 60,
  kSignTIcyRoad = 61,
  kSignTFallingRocksRight = 62,
  kSignTDanger = 63,
  kSignTDomesticAnimalsCrossing = 64,
  kSignTLeftSideDetour = 65,
  kSignTLeftRightDetour = 66,
  kSignTVehiclesLineAhead = 67,
  kSignTYIntersection = 68,
  kSignTIntersectionCross = 69,
  kSignTSlope = 70,
  kSignTXSymbol = 71,
  kSignTSlashSymbol = 72,
  kSignTElectricBicycle = 73,
  kSignTTrafficAccident = 74,
  kSignTRecommendedSpeed = 75,
  kSignTEscapeLane = 76,
  kSignTPayAttentionToFewerLanes = 77,
  kSignTLinearGuideSign = 78,
  kSignTPonding = 79,
  kSignTOvertakingProhibited = 101,
  kSignTAnimalPoweredVehiclesProhibited = 102,
  kSignTLargeBusProhibited = 103,
  kSignTElectricTricycleProhibited = 104,
  kSignTUTurnProhibited = 105,
  kSignTNonMotorVehicleProhibited = 106,
  kSignTTruckToLeftProhibited = 107,
  kSignTTrailerProhibited = 108,
  kSignTPedestrianProhibited = 109,
  kSignTVehicleProhibited = 110,
  kSignTHonkingProhibited = 111,
  kSignTMotorcycleProhibited = 112,
  kSignTTwoVehicleOfSignProhibited = 113,
  kSignTGoStraightProhibited = 114,
  kSignTNoRickshaw = 115,
  kSignTNoHumanFreightTricycle = 116,
  kSignTNoHumanPassengerTricycle = 117,
  kSignTNoTractor = 118,
  kSignTTurnRightProhibited = 119,
  kSignTTurnLeftOrRightProhibited = 120,
  kSignTGoStraightAndTurnRightProhibited = 121,
  kSignTNoThreeWheelAndLowSpeedTruck = 122,
  kSignTTurnLeftProhibited = 123,
  kSignTMinibusTurnRightProhibited = 124,
  kSignTMinibusProhibited = 125,
  kSignTNoTruck = 126,
  kSignTNoVehiclesWthDangerousGoods = 127,
  kSignTGoStraightAndTurnLeftProhibited = 128,
  kSignTLimitWeight = 129,
  kSignTLimitedAxleLoad = 130,
  kSignTCustoms = 131,
  kSignTParkingInspection = 132,
  kSignTParkingProhibited = 133,
  kSignTLongTimeParkingProhibited = 134,
  kSignTMaxSpeedLimit = 135,
  kSignTEndOfSpeedLimit = 136,
  kSignTLimitHeight = 137,
  kSignTLimitWidth = 138,
  kSignTStopAtIntersection = 139,
  kSignTSlowDownAndGiveWay = 140,
  kSignTStop = 141,
  kSignTGiveWay = 142,
  kSignTNoEntrance = 143,
  kSignTEndOfProhibitionOnOvertaking = 144,
  kSignTNoElectricBicycles = 145,
  kSignTNoCarTurningLeft = 146,
  kSignTNoTruckTurningRight = 147,
  kSignTPortParkingInspection = 148,
  kSignTNoParkingLong = 149,
  kSignTEndOfNoParkingLong = 150,
  kSignTNoParking = 151,
  kSignEndOfNoParking = 152,
  kSignTRegionalSpeedLimit = 153,
  kSignTEndOfRegionalSpeedLimit = 154,
  kSignTWalk = 201,
  kSignTNonMotorVehicleDriving = 202,
  kSignTRoundaboutDriving = 203,
  kSignTVehicleDriving = 204,
  kSignTDriveOnTheRightSide = 205,
  kSignTDriveOnTheLeftSide = 206,
  kSignTGradeSeparationStraightAndRightTurn = 207,
  kSignTGradeSeparationStraightAndLeftTurn = 208,
  kSignTHonking = 209,
  kSignTPassRightSide = 210,
  kSignTPassLeftOrRightSide = 211,
  kSignTPassLeftSide = 212,
  kSignTGoStraight = 213,
  kSignTGoStraightAndTurnRight = 214,
  kSignTGoStraightAndTurnLeft = 215,
  kSignTDirectionToTheLeft = 216,
  kSignTDirectionToTheRight = 217,
  kSignTPriorityRoad = 218,
  kSignTMeetingFirst = 219,
  kSignTRightTurnLane = 220,
  kSignTLeftTurnLane = 221,
  kSignTStraightLane = 222,
  kSignTThroughAndRightTurnSharedLane = 223,
  kSignTThroughAndLeftTurnSharedLane = 224,
  kSignTUTurnLane = 225,
  kSignTUTurnAndLeftTurnSharedLane = 226,
  kSignTBusLane = 227,
  kSignTMotorVehicleLane = 228,
  kSignTNonMotorVehicleLane = 229,
  kSignTBRTLane = 230,
  kSignTMultiOccupantVehiclesLane = 231,
  kSignTSlot = 232,
  kSignTAllowUTurn = 233,
  kSignTMinSpeedLimit = 234,
  kSignTPedestrianCrossing = 235,
  kSignTOpenLights = 236,
  kSignTCombinationSettings = 237,
  kSignTCombinationSettings1 = 238,
  kSignTMinibusLane = 239,
  kSignTRunningSignOfElectricBicycle = 240,
  kSignTElectricBicycleLane = 241,
  kSignTNonMotorAndPedestrianSeparate = 242,
  kSignTNonMotorAndPedestrianShare = 243,
  kSignTDifferentSpecialLaneSigns = 244,
  kSignTNonMotorVehiclePromotion = 245,
  kSignTDriveRight = 246,
  kSignTTramLane = 247,
  kSignTDisableParking = 248,
  kSignTSchoolBusParking = 249,
  kSignTTaxiParking = 250,
  kSignTNonMotorVehicleParking = 251,
  kSignTBusParking = 252,
  kSignTChargingParking = 253,
  kSignTExclusiveParking = 254,
  kSignTHardShoulderPermission = 255,
  kSignTTruckPassage = 256,
  kSignTTimeLimitedParking = 257,
  kSignTOneStraight = 258,
  kSignTOther = 401,
  SignType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SignType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SignType_IsValid(int value);
constexpr SignType SignType_MIN = kSignTUnknown;
constexpr SignType SignType_MAX = kSignTOther;
constexpr int SignType_ARRAYSIZE = SignType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SignType_descriptor();
template<typename T>
inline const std::string& SignType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SignType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SignType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SignType_descriptor(), enum_t_value);
}
inline bool SignType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SignType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SignType>(
    SignType_descriptor(), name, value);
}
enum LaneNodeType : int {
  kLaneNTUnknown = 0,
  kLaneNTStartBifurcation = 1,
  kLaneNTEndBifurcation = 2,
  kLaneNTParkingEntrance = 3,
  kLaneNTParkingExist = 4,
  kLaneNTChangeLineShape = 5,
  kLaneNTStartTunnel = 6,
  kLaneNTEndTunnel = 7,
  kLaneNTChangeTile = 8,
  kLaneNTEndOfLane = 9,
  kLaneNTOther = 99,
  LaneNodeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LaneNodeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LaneNodeType_IsValid(int value);
constexpr LaneNodeType LaneNodeType_MIN = kLaneNTUnknown;
constexpr LaneNodeType LaneNodeType_MAX = kLaneNTOther;
constexpr int LaneNodeType_ARRAYSIZE = LaneNodeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LaneNodeType_descriptor();
template<typename T>
inline const std::string& LaneNodeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LaneNodeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LaneNodeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LaneNodeType_descriptor(), enum_t_value);
}
inline bool LaneNodeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LaneNodeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LaneNodeType>(
    LaneNodeType_descriptor(), name, value);
}
enum GroundMarkType : int {
  kGMTInvalid = 0,
  kGMTPedestrianCrossing = 1,
  kGMTStopLine = 2,
  kGMTSpeedBump = 3,
  kGMTWord = 4,
  kGMTStopYieldLine = 5,
  kGMTDecelerationYieldLine = 6,
  kGMTArrow = 7,
  kGMTGroundSpeedLimit = 8,
  kGMTNonMotorizedLaneMarking = 9,
  kGMTSlot = 10,
  kGMTAntiskidRampMarkings = 11,
  kGMTFloorLock = 12,
  kGMTStopper = 13,
  kGMTPedestrianArea = 14,
  kGMTDiversionArea = 15,
  kGMTDiversionAreaV = 16,
  kGMTDiversionAreaStraight = 17,
  kGMTNoParkingArea = 18,
  kGMTNoOtherSpeedBump = 19,
  kGMTOther = 99,
  GroundMarkType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GroundMarkType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GroundMarkType_IsValid(int value);
constexpr GroundMarkType GroundMarkType_MIN = kGMTInvalid;
constexpr GroundMarkType GroundMarkType_MAX = kGMTOther;
constexpr int GroundMarkType_ARRAYSIZE = GroundMarkType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GroundMarkType_descriptor();
template<typename T>
inline const std::string& GroundMarkType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GroundMarkType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GroundMarkType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GroundMarkType_descriptor(), enum_t_value);
}
inline bool GroundMarkType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroundMarkType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GroundMarkType>(
    GroundMarkType_descriptor(), name, value);
}
enum GroundMarkPattern : int {
  kGMPUnknown = 0,
  kGMPForward = 1,
  kGMPRight = 2,
  kGMPRightAndForward = 3,
  kGMPLeft = 4,
  kGMPLeftAndForward = 5,
  kGMPLeftAndRight = 6,
  kGMPUturn = 7,
  kGMPForwardAndUturn = 8,
  kGMPLeftAndUturn = 9,
  kGMPLeftConfluence = 10,
  kGMPRightConfluence = 11,
  kGMPNoLeftTurn = 12,
  kGMPNoRightTurn = 13,
  kGMPFwardAndLeftAndRight = 14,
  kGMPForwardAndLeftAndUturn = 15,
  kGMPTurnRightAndUturn = 16,
  kGMPNoUturn = 17,
  kGMPMaximumSpeedLimitStyle1 = 18,
  kGMPMaximumSpeedLimitStyle2 = 19,
  kGMPMaximumSpeedLimitStyle3 = 20,
  kGMPMinimumSpeedLimitStyle1 = 21,
  kGMPMinimumSpeedLimitStyle2 = 22,
  kGMPUturnAndLeftAndRight = 23,
  kGMPOther = 99,
  GroundMarkPattern_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GroundMarkPattern_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GroundMarkPattern_IsValid(int value);
constexpr GroundMarkPattern GroundMarkPattern_MIN = kGMPUnknown;
constexpr GroundMarkPattern GroundMarkPattern_MAX = kGMPOther;
constexpr int GroundMarkPattern_ARRAYSIZE = GroundMarkPattern_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GroundMarkPattern_descriptor();
template<typename T>
inline const std::string& GroundMarkPattern_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GroundMarkPattern>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GroundMarkPattern_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GroundMarkPattern_descriptor(), enum_t_value);
}
inline bool GroundMarkPattern_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroundMarkPattern* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GroundMarkPattern>(
    GroundMarkPattern_descriptor(), name, value);
}
// ===================================================================

class Gnss final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idmap.Gnss) */ {
 public:
  inline Gnss() : Gnss(nullptr) {}
  ~Gnss() override;
  explicit PROTOBUF_CONSTEXPR Gnss(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Gnss(const Gnss& from);
  Gnss(Gnss&& from) noexcept
    : Gnss() {
    *this = ::std::move(from);
  }

  inline Gnss& operator=(const Gnss& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gnss& operator=(Gnss&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Gnss& default_instance() {
    return *internal_default_instance();
  }
  static inline const Gnss* internal_default_instance() {
    return reinterpret_cast<const Gnss*>(
               &_Gnss_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Gnss& a, Gnss& b) {
    a.Swap(&b);
  }
  inline void Swap(Gnss* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gnss* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Gnss* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Gnss>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Gnss& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Gnss& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gnss* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idmap.Gnss";
  }
  protected:
  explicit Gnss(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLngFieldNumber = 1,
    kLatFieldNumber = 2,
    kHeightFieldNumber = 3,
  };
  // double lng = 1;
  void clear_lng();
  double lng() const;
  void set_lng(double value);
  private:
  double _internal_lng() const;
  void _internal_set_lng(double value);
  public:

  // double lat = 2;
  void clear_lat();
  double lat() const;
  void set_lat(double value);
  private:
  double _internal_lat() const;
  void _internal_set_lat(double value);
  public:

  // double height = 3;
  void clear_height();
  double height() const;
  void set_height(double value);
  private:
  double _internal_height() const;
  void _internal_set_height(double value);
  public:

  // @@protoc_insertion_point(class_scope:idmap.Gnss)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double lng_;
  double lat_;
  double height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_idmap_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class Zlevel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idmap.Zlevel) */ {
 public:
  inline Zlevel() : Zlevel(nullptr) {}
  ~Zlevel() override;
  explicit PROTOBUF_CONSTEXPR Zlevel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Zlevel(const Zlevel& from);
  Zlevel(Zlevel&& from) noexcept
    : Zlevel() {
    *this = ::std::move(from);
  }

  inline Zlevel& operator=(const Zlevel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Zlevel& operator=(Zlevel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Zlevel& default_instance() {
    return *internal_default_instance();
  }
  static inline const Zlevel* internal_default_instance() {
    return reinterpret_cast<const Zlevel*>(
               &_Zlevel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Zlevel& a, Zlevel& b) {
    a.Swap(&b);
  }
  inline void Swap(Zlevel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Zlevel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Zlevel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Zlevel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Zlevel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Zlevel& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Zlevel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idmap.Zlevel";
  }
  protected:
  explicit Zlevel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZlevelIdFieldNumber = 1,
    kLaneLevelFieldNumber = 2,
    kSumOfLevelFieldNumber = 3,
  };
  // .idmap.Gnss zlevel_id = 1;
  bool has_zlevel_id() const;
  private:
  bool _internal_has_zlevel_id() const;
  public:
  void clear_zlevel_id();
  const ::idmap::Gnss& zlevel_id() const;
  PROTOBUF_NODISCARD ::idmap::Gnss* release_zlevel_id();
  ::idmap::Gnss* mutable_zlevel_id();
  void set_allocated_zlevel_id(::idmap::Gnss* zlevel_id);
  private:
  const ::idmap::Gnss& _internal_zlevel_id() const;
  ::idmap::Gnss* _internal_mutable_zlevel_id();
  public:
  void unsafe_arena_set_allocated_zlevel_id(
      ::idmap::Gnss* zlevel_id);
  ::idmap::Gnss* unsafe_arena_release_zlevel_id();

  // uint64 lane_level = 2;
  void clear_lane_level();
  uint64_t lane_level() const;
  void set_lane_level(uint64_t value);
  private:
  uint64_t _internal_lane_level() const;
  void _internal_set_lane_level(uint64_t value);
  public:

  // uint32 sum_of_level = 3;
  void clear_sum_of_level();
  uint32_t sum_of_level() const;
  void set_sum_of_level(uint32_t value);
  private:
  uint32_t _internal_sum_of_level() const;
  void _internal_set_sum_of_level(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idmap.Zlevel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::idmap::Gnss* zlevel_id_;
  uint64_t lane_level_;
  uint32_t sum_of_level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_idmap_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class IDMapStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idmap.IDMapStatus) */ {
 public:
  inline IDMapStatus() : IDMapStatus(nullptr) {}
  ~IDMapStatus() override;
  explicit PROTOBUF_CONSTEXPR IDMapStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IDMapStatus(const IDMapStatus& from);
  IDMapStatus(IDMapStatus&& from) noexcept
    : IDMapStatus() {
    *this = ::std::move(from);
  }

  inline IDMapStatus& operator=(const IDMapStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline IDMapStatus& operator=(IDMapStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IDMapStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const IDMapStatus* internal_default_instance() {
    return reinterpret_cast<const IDMapStatus*>(
               &_IDMapStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(IDMapStatus& a, IDMapStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(IDMapStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IDMapStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IDMapStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IDMapStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IDMapStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IDMapStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IDMapStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idmap.IDMapStatus";
  }
  protected:
  explicit IDMapStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapAvailableFieldNumber = 1,
    kUpdateStatusFieldNumber = 2,
    kMapVersionFieldNumber = 3,
    kApiVersionFieldNumber = 4,
  };
  // bool map_available = 1;
  void clear_map_available();
  bool map_available() const;
  void set_map_available(bool value);
  private:
  bool _internal_map_available() const;
  void _internal_set_map_available(bool value);
  public:

  // uint32 update_status = 2;
  void clear_update_status();
  uint32_t update_status() const;
  void set_update_status(uint32_t value);
  private:
  uint32_t _internal_update_status() const;
  void _internal_set_update_status(uint32_t value);
  public:

  // uint32 map_version = 3;
  void clear_map_version();
  uint32_t map_version() const;
  void set_map_version(uint32_t value);
  private:
  uint32_t _internal_map_version() const;
  void _internal_set_map_version(uint32_t value);
  public:

  // uint32 api_version = 4;
  void clear_api_version();
  uint32_t api_version() const;
  void set_api_version(uint32_t value);
  private:
  uint32_t _internal_api_version() const;
  void _internal_set_api_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idmap.IDMapStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool map_available_;
  uint32_t update_status_;
  uint32_t map_version_;
  uint32_t api_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_idmap_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class LaneAttribute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idmap.LaneAttribute) */ {
 public:
  inline LaneAttribute() : LaneAttribute(nullptr) {}
  ~LaneAttribute() override;
  explicit PROTOBUF_CONSTEXPR LaneAttribute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaneAttribute(const LaneAttribute& from);
  LaneAttribute(LaneAttribute&& from) noexcept
    : LaneAttribute() {
    *this = ::std::move(from);
  }

  inline LaneAttribute& operator=(const LaneAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneAttribute& operator=(LaneAttribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneAttribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneAttribute* internal_default_instance() {
    return reinterpret_cast<const LaneAttribute*>(
               &_LaneAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LaneAttribute& a, LaneAttribute& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneAttribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneAttribute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneAttribute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneAttribute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaneAttribute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LaneAttribute& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneAttribute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idmap.LaneAttribute";
  }
  protected:
  explicit LaneAttribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdasPointFieldNumber = 1,
    kAttributeValueFieldNumber = 2,
  };
  // .idmap.Gnss adas_point = 1;
  bool has_adas_point() const;
  private:
  bool _internal_has_adas_point() const;
  public:
  void clear_adas_point();
  const ::idmap::Gnss& adas_point() const;
  PROTOBUF_NODISCARD ::idmap::Gnss* release_adas_point();
  ::idmap::Gnss* mutable_adas_point();
  void set_allocated_adas_point(::idmap::Gnss* adas_point);
  private:
  const ::idmap::Gnss& _internal_adas_point() const;
  ::idmap::Gnss* _internal_mutable_adas_point();
  public:
  void unsafe_arena_set_allocated_adas_point(
      ::idmap::Gnss* adas_point);
  ::idmap::Gnss* unsafe_arena_release_adas_point();

  // double attribute_value = 2;
  void clear_attribute_value();
  double attribute_value() const;
  void set_attribute_value(double value);
  private:
  double _internal_attribute_value() const;
  void _internal_set_attribute_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:idmap.LaneAttribute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::idmap::Gnss* adas_point_;
  double attribute_value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_idmap_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class LaneNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idmap.LaneNode) */ {
 public:
  inline LaneNode() : LaneNode(nullptr) {}
  ~LaneNode() override;
  explicit PROTOBUF_CONSTEXPR LaneNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaneNode(const LaneNode& from);
  LaneNode(LaneNode&& from) noexcept
    : LaneNode() {
    *this = ::std::move(from);
  }

  inline LaneNode& operator=(const LaneNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneNode& operator=(LaneNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneNode* internal_default_instance() {
    return reinterpret_cast<const LaneNode*>(
               &_LaneNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LaneNode& a, LaneNode& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaneNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LaneNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idmap.LaneNode";
  }
  protected:
  explicit LaneNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLaneNodeTypeFieldNumber = 2,
    kLaneNodeIdFieldNumber = 1,
  };
  // repeated .idmap.LaneNodeType lane_node_type = 2;
  int lane_node_type_size() const;
  private:
  int _internal_lane_node_type_size() const;
  public:
  void clear_lane_node_type();
  private:
  ::idmap::LaneNodeType _internal_lane_node_type(int index) const;
  void _internal_add_lane_node_type(::idmap::LaneNodeType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_lane_node_type();
  public:
  ::idmap::LaneNodeType lane_node_type(int index) const;
  void set_lane_node_type(int index, ::idmap::LaneNodeType value);
  void add_lane_node_type(::idmap::LaneNodeType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& lane_node_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_lane_node_type();

  // .idmap.Gnss lane_node_id = 1;
  bool has_lane_node_id() const;
  private:
  bool _internal_has_lane_node_id() const;
  public:
  void clear_lane_node_id();
  const ::idmap::Gnss& lane_node_id() const;
  PROTOBUF_NODISCARD ::idmap::Gnss* release_lane_node_id();
  ::idmap::Gnss* mutable_lane_node_id();
  void set_allocated_lane_node_id(::idmap::Gnss* lane_node_id);
  private:
  const ::idmap::Gnss& _internal_lane_node_id() const;
  ::idmap::Gnss* _internal_mutable_lane_node_id();
  public:
  void unsafe_arena_set_allocated_lane_node_id(
      ::idmap::Gnss* lane_node_id);
  ::idmap::Gnss* unsafe_arena_release_lane_node_id();

  // @@protoc_insertion_point(class_scope:idmap.LaneNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> lane_node_type_;
  mutable std::atomic<int> _lane_node_type_cached_byte_size_;
  ::idmap::Gnss* lane_node_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_idmap_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class NotODD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idmap.NotODD) */ {
 public:
  inline NotODD() : NotODD(nullptr) {}
  ~NotODD() override;
  explicit PROTOBUF_CONSTEXPR NotODD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotODD(const NotODD& from);
  NotODD(NotODD&& from) noexcept
    : NotODD() {
    *this = ::std::move(from);
  }

  inline NotODD& operator=(const NotODD& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotODD& operator=(NotODD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotODD& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotODD* internal_default_instance() {
    return reinterpret_cast<const NotODD*>(
               &_NotODD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NotODD& a, NotODD& b) {
    a.Swap(&b);
  }
  inline void Swap(NotODD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotODD* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotODD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotODD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotODD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NotODD& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotODD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idmap.NotODD";
  }
  protected:
  explicit NotODD(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFromLaneBeginningFieldNumber = 2,
    kDisToStartFieldNumber = 3,
    kNotOddTypeFieldNumber = 1,
  };
  // double start_from_lane_beginning = 2;
  void clear_start_from_lane_beginning();
  double start_from_lane_beginning() const;
  void set_start_from_lane_beginning(double value);
  private:
  double _internal_start_from_lane_beginning() const;
  void _internal_set_start_from_lane_beginning(double value);
  public:

  // double dis_to_start = 3;
  void clear_dis_to_start();
  double dis_to_start() const;
  void set_dis_to_start(double value);
  private:
  double _internal_dis_to_start() const;
  void _internal_set_dis_to_start(double value);
  public:

  // uint32 not_odd_type = 1;
  void clear_not_odd_type();
  uint32_t not_odd_type() const;
  void set_not_odd_type(uint32_t value);
  private:
  uint32_t _internal_not_odd_type() const;
  void _internal_set_not_odd_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idmap.NotODD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double start_from_lane_beginning_;
  double dis_to_start_;
  uint32_t not_odd_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_idmap_5fcommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Gnss

// double lng = 1;
inline void Gnss::clear_lng() {
  lng_ = 0;
}
inline double Gnss::_internal_lng() const {
  return lng_;
}
inline double Gnss::lng() const {
  // @@protoc_insertion_point(field_get:idmap.Gnss.lng)
  return _internal_lng();
}
inline void Gnss::_internal_set_lng(double value) {
  
  lng_ = value;
}
inline void Gnss::set_lng(double value) {
  _internal_set_lng(value);
  // @@protoc_insertion_point(field_set:idmap.Gnss.lng)
}

// double lat = 2;
inline void Gnss::clear_lat() {
  lat_ = 0;
}
inline double Gnss::_internal_lat() const {
  return lat_;
}
inline double Gnss::lat() const {
  // @@protoc_insertion_point(field_get:idmap.Gnss.lat)
  return _internal_lat();
}
inline void Gnss::_internal_set_lat(double value) {
  
  lat_ = value;
}
inline void Gnss::set_lat(double value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:idmap.Gnss.lat)
}

// double height = 3;
inline void Gnss::clear_height() {
  height_ = 0;
}
inline double Gnss::_internal_height() const {
  return height_;
}
inline double Gnss::height() const {
  // @@protoc_insertion_point(field_get:idmap.Gnss.height)
  return _internal_height();
}
inline void Gnss::_internal_set_height(double value) {
  
  height_ = value;
}
inline void Gnss::set_height(double value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:idmap.Gnss.height)
}

// -------------------------------------------------------------------

// Zlevel

// .idmap.Gnss zlevel_id = 1;
inline bool Zlevel::_internal_has_zlevel_id() const {
  return this != internal_default_instance() && zlevel_id_ != nullptr;
}
inline bool Zlevel::has_zlevel_id() const {
  return _internal_has_zlevel_id();
}
inline void Zlevel::clear_zlevel_id() {
  if (GetArenaForAllocation() == nullptr && zlevel_id_ != nullptr) {
    delete zlevel_id_;
  }
  zlevel_id_ = nullptr;
}
inline const ::idmap::Gnss& Zlevel::_internal_zlevel_id() const {
  const ::idmap::Gnss* p = zlevel_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::idmap::Gnss&>(
      ::idmap::_Gnss_default_instance_);
}
inline const ::idmap::Gnss& Zlevel::zlevel_id() const {
  // @@protoc_insertion_point(field_get:idmap.Zlevel.zlevel_id)
  return _internal_zlevel_id();
}
inline void Zlevel::unsafe_arena_set_allocated_zlevel_id(
    ::idmap::Gnss* zlevel_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(zlevel_id_);
  }
  zlevel_id_ = zlevel_id;
  if (zlevel_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idmap.Zlevel.zlevel_id)
}
inline ::idmap::Gnss* Zlevel::release_zlevel_id() {
  
  ::idmap::Gnss* temp = zlevel_id_;
  zlevel_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idmap::Gnss* Zlevel::unsafe_arena_release_zlevel_id() {
  // @@protoc_insertion_point(field_release:idmap.Zlevel.zlevel_id)
  
  ::idmap::Gnss* temp = zlevel_id_;
  zlevel_id_ = nullptr;
  return temp;
}
inline ::idmap::Gnss* Zlevel::_internal_mutable_zlevel_id() {
  
  if (zlevel_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::idmap::Gnss>(GetArenaForAllocation());
    zlevel_id_ = p;
  }
  return zlevel_id_;
}
inline ::idmap::Gnss* Zlevel::mutable_zlevel_id() {
  ::idmap::Gnss* _msg = _internal_mutable_zlevel_id();
  // @@protoc_insertion_point(field_mutable:idmap.Zlevel.zlevel_id)
  return _msg;
}
inline void Zlevel::set_allocated_zlevel_id(::idmap::Gnss* zlevel_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete zlevel_id_;
  }
  if (zlevel_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(zlevel_id);
    if (message_arena != submessage_arena) {
      zlevel_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, zlevel_id, submessage_arena);
    }
    
  } else {
    
  }
  zlevel_id_ = zlevel_id;
  // @@protoc_insertion_point(field_set_allocated:idmap.Zlevel.zlevel_id)
}

// uint64 lane_level = 2;
inline void Zlevel::clear_lane_level() {
  lane_level_ = uint64_t{0u};
}
inline uint64_t Zlevel::_internal_lane_level() const {
  return lane_level_;
}
inline uint64_t Zlevel::lane_level() const {
  // @@protoc_insertion_point(field_get:idmap.Zlevel.lane_level)
  return _internal_lane_level();
}
inline void Zlevel::_internal_set_lane_level(uint64_t value) {
  
  lane_level_ = value;
}
inline void Zlevel::set_lane_level(uint64_t value) {
  _internal_set_lane_level(value);
  // @@protoc_insertion_point(field_set:idmap.Zlevel.lane_level)
}

// uint32 sum_of_level = 3;
inline void Zlevel::clear_sum_of_level() {
  sum_of_level_ = 0u;
}
inline uint32_t Zlevel::_internal_sum_of_level() const {
  return sum_of_level_;
}
inline uint32_t Zlevel::sum_of_level() const {
  // @@protoc_insertion_point(field_get:idmap.Zlevel.sum_of_level)
  return _internal_sum_of_level();
}
inline void Zlevel::_internal_set_sum_of_level(uint32_t value) {
  
  sum_of_level_ = value;
}
inline void Zlevel::set_sum_of_level(uint32_t value) {
  _internal_set_sum_of_level(value);
  // @@protoc_insertion_point(field_set:idmap.Zlevel.sum_of_level)
}

// -------------------------------------------------------------------

// IDMapStatus

// bool map_available = 1;
inline void IDMapStatus::clear_map_available() {
  map_available_ = false;
}
inline bool IDMapStatus::_internal_map_available() const {
  return map_available_;
}
inline bool IDMapStatus::map_available() const {
  // @@protoc_insertion_point(field_get:idmap.IDMapStatus.map_available)
  return _internal_map_available();
}
inline void IDMapStatus::_internal_set_map_available(bool value) {
  
  map_available_ = value;
}
inline void IDMapStatus::set_map_available(bool value) {
  _internal_set_map_available(value);
  // @@protoc_insertion_point(field_set:idmap.IDMapStatus.map_available)
}

// uint32 update_status = 2;
inline void IDMapStatus::clear_update_status() {
  update_status_ = 0u;
}
inline uint32_t IDMapStatus::_internal_update_status() const {
  return update_status_;
}
inline uint32_t IDMapStatus::update_status() const {
  // @@protoc_insertion_point(field_get:idmap.IDMapStatus.update_status)
  return _internal_update_status();
}
inline void IDMapStatus::_internal_set_update_status(uint32_t value) {
  
  update_status_ = value;
}
inline void IDMapStatus::set_update_status(uint32_t value) {
  _internal_set_update_status(value);
  // @@protoc_insertion_point(field_set:idmap.IDMapStatus.update_status)
}

// uint32 map_version = 3;
inline void IDMapStatus::clear_map_version() {
  map_version_ = 0u;
}
inline uint32_t IDMapStatus::_internal_map_version() const {
  return map_version_;
}
inline uint32_t IDMapStatus::map_version() const {
  // @@protoc_insertion_point(field_get:idmap.IDMapStatus.map_version)
  return _internal_map_version();
}
inline void IDMapStatus::_internal_set_map_version(uint32_t value) {
  
  map_version_ = value;
}
inline void IDMapStatus::set_map_version(uint32_t value) {
  _internal_set_map_version(value);
  // @@protoc_insertion_point(field_set:idmap.IDMapStatus.map_version)
}

// uint32 api_version = 4;
inline void IDMapStatus::clear_api_version() {
  api_version_ = 0u;
}
inline uint32_t IDMapStatus::_internal_api_version() const {
  return api_version_;
}
inline uint32_t IDMapStatus::api_version() const {
  // @@protoc_insertion_point(field_get:idmap.IDMapStatus.api_version)
  return _internal_api_version();
}
inline void IDMapStatus::_internal_set_api_version(uint32_t value) {
  
  api_version_ = value;
}
inline void IDMapStatus::set_api_version(uint32_t value) {
  _internal_set_api_version(value);
  // @@protoc_insertion_point(field_set:idmap.IDMapStatus.api_version)
}

// -------------------------------------------------------------------

// LaneAttribute

// .idmap.Gnss adas_point = 1;
inline bool LaneAttribute::_internal_has_adas_point() const {
  return this != internal_default_instance() && adas_point_ != nullptr;
}
inline bool LaneAttribute::has_adas_point() const {
  return _internal_has_adas_point();
}
inline void LaneAttribute::clear_adas_point() {
  if (GetArenaForAllocation() == nullptr && adas_point_ != nullptr) {
    delete adas_point_;
  }
  adas_point_ = nullptr;
}
inline const ::idmap::Gnss& LaneAttribute::_internal_adas_point() const {
  const ::idmap::Gnss* p = adas_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::idmap::Gnss&>(
      ::idmap::_Gnss_default_instance_);
}
inline const ::idmap::Gnss& LaneAttribute::adas_point() const {
  // @@protoc_insertion_point(field_get:idmap.LaneAttribute.adas_point)
  return _internal_adas_point();
}
inline void LaneAttribute::unsafe_arena_set_allocated_adas_point(
    ::idmap::Gnss* adas_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(adas_point_);
  }
  adas_point_ = adas_point;
  if (adas_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idmap.LaneAttribute.adas_point)
}
inline ::idmap::Gnss* LaneAttribute::release_adas_point() {
  
  ::idmap::Gnss* temp = adas_point_;
  adas_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idmap::Gnss* LaneAttribute::unsafe_arena_release_adas_point() {
  // @@protoc_insertion_point(field_release:idmap.LaneAttribute.adas_point)
  
  ::idmap::Gnss* temp = adas_point_;
  adas_point_ = nullptr;
  return temp;
}
inline ::idmap::Gnss* LaneAttribute::_internal_mutable_adas_point() {
  
  if (adas_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::idmap::Gnss>(GetArenaForAllocation());
    adas_point_ = p;
  }
  return adas_point_;
}
inline ::idmap::Gnss* LaneAttribute::mutable_adas_point() {
  ::idmap::Gnss* _msg = _internal_mutable_adas_point();
  // @@protoc_insertion_point(field_mutable:idmap.LaneAttribute.adas_point)
  return _msg;
}
inline void LaneAttribute::set_allocated_adas_point(::idmap::Gnss* adas_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete adas_point_;
  }
  if (adas_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(adas_point);
    if (message_arena != submessage_arena) {
      adas_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, adas_point, submessage_arena);
    }
    
  } else {
    
  }
  adas_point_ = adas_point;
  // @@protoc_insertion_point(field_set_allocated:idmap.LaneAttribute.adas_point)
}

// double attribute_value = 2;
inline void LaneAttribute::clear_attribute_value() {
  attribute_value_ = 0;
}
inline double LaneAttribute::_internal_attribute_value() const {
  return attribute_value_;
}
inline double LaneAttribute::attribute_value() const {
  // @@protoc_insertion_point(field_get:idmap.LaneAttribute.attribute_value)
  return _internal_attribute_value();
}
inline void LaneAttribute::_internal_set_attribute_value(double value) {
  
  attribute_value_ = value;
}
inline void LaneAttribute::set_attribute_value(double value) {
  _internal_set_attribute_value(value);
  // @@protoc_insertion_point(field_set:idmap.LaneAttribute.attribute_value)
}

// -------------------------------------------------------------------

// LaneNode

// .idmap.Gnss lane_node_id = 1;
inline bool LaneNode::_internal_has_lane_node_id() const {
  return this != internal_default_instance() && lane_node_id_ != nullptr;
}
inline bool LaneNode::has_lane_node_id() const {
  return _internal_has_lane_node_id();
}
inline void LaneNode::clear_lane_node_id() {
  if (GetArenaForAllocation() == nullptr && lane_node_id_ != nullptr) {
    delete lane_node_id_;
  }
  lane_node_id_ = nullptr;
}
inline const ::idmap::Gnss& LaneNode::_internal_lane_node_id() const {
  const ::idmap::Gnss* p = lane_node_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::idmap::Gnss&>(
      ::idmap::_Gnss_default_instance_);
}
inline const ::idmap::Gnss& LaneNode::lane_node_id() const {
  // @@protoc_insertion_point(field_get:idmap.LaneNode.lane_node_id)
  return _internal_lane_node_id();
}
inline void LaneNode::unsafe_arena_set_allocated_lane_node_id(
    ::idmap::Gnss* lane_node_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lane_node_id_);
  }
  lane_node_id_ = lane_node_id;
  if (lane_node_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idmap.LaneNode.lane_node_id)
}
inline ::idmap::Gnss* LaneNode::release_lane_node_id() {
  
  ::idmap::Gnss* temp = lane_node_id_;
  lane_node_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idmap::Gnss* LaneNode::unsafe_arena_release_lane_node_id() {
  // @@protoc_insertion_point(field_release:idmap.LaneNode.lane_node_id)
  
  ::idmap::Gnss* temp = lane_node_id_;
  lane_node_id_ = nullptr;
  return temp;
}
inline ::idmap::Gnss* LaneNode::_internal_mutable_lane_node_id() {
  
  if (lane_node_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::idmap::Gnss>(GetArenaForAllocation());
    lane_node_id_ = p;
  }
  return lane_node_id_;
}
inline ::idmap::Gnss* LaneNode::mutable_lane_node_id() {
  ::idmap::Gnss* _msg = _internal_mutable_lane_node_id();
  // @@protoc_insertion_point(field_mutable:idmap.LaneNode.lane_node_id)
  return _msg;
}
inline void LaneNode::set_allocated_lane_node_id(::idmap::Gnss* lane_node_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete lane_node_id_;
  }
  if (lane_node_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lane_node_id);
    if (message_arena != submessage_arena) {
      lane_node_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lane_node_id, submessage_arena);
    }
    
  } else {
    
  }
  lane_node_id_ = lane_node_id;
  // @@protoc_insertion_point(field_set_allocated:idmap.LaneNode.lane_node_id)
}

// repeated .idmap.LaneNodeType lane_node_type = 2;
inline int LaneNode::_internal_lane_node_type_size() const {
  return lane_node_type_.size();
}
inline int LaneNode::lane_node_type_size() const {
  return _internal_lane_node_type_size();
}
inline void LaneNode::clear_lane_node_type() {
  lane_node_type_.Clear();
}
inline ::idmap::LaneNodeType LaneNode::_internal_lane_node_type(int index) const {
  return static_cast< ::idmap::LaneNodeType >(lane_node_type_.Get(index));
}
inline ::idmap::LaneNodeType LaneNode::lane_node_type(int index) const {
  // @@protoc_insertion_point(field_get:idmap.LaneNode.lane_node_type)
  return _internal_lane_node_type(index);
}
inline void LaneNode::set_lane_node_type(int index, ::idmap::LaneNodeType value) {
  lane_node_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:idmap.LaneNode.lane_node_type)
}
inline void LaneNode::_internal_add_lane_node_type(::idmap::LaneNodeType value) {
  lane_node_type_.Add(value);
}
inline void LaneNode::add_lane_node_type(::idmap::LaneNodeType value) {
  _internal_add_lane_node_type(value);
  // @@protoc_insertion_point(field_add:idmap.LaneNode.lane_node_type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
LaneNode::lane_node_type() const {
  // @@protoc_insertion_point(field_list:idmap.LaneNode.lane_node_type)
  return lane_node_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
LaneNode::_internal_mutable_lane_node_type() {
  return &lane_node_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
LaneNode::mutable_lane_node_type() {
  // @@protoc_insertion_point(field_mutable_list:idmap.LaneNode.lane_node_type)
  return _internal_mutable_lane_node_type();
}

// -------------------------------------------------------------------

// NotODD

// uint32 not_odd_type = 1;
inline void NotODD::clear_not_odd_type() {
  not_odd_type_ = 0u;
}
inline uint32_t NotODD::_internal_not_odd_type() const {
  return not_odd_type_;
}
inline uint32_t NotODD::not_odd_type() const {
  // @@protoc_insertion_point(field_get:idmap.NotODD.not_odd_type)
  return _internal_not_odd_type();
}
inline void NotODD::_internal_set_not_odd_type(uint32_t value) {
  
  not_odd_type_ = value;
}
inline void NotODD::set_not_odd_type(uint32_t value) {
  _internal_set_not_odd_type(value);
  // @@protoc_insertion_point(field_set:idmap.NotODD.not_odd_type)
}

// double start_from_lane_beginning = 2;
inline void NotODD::clear_start_from_lane_beginning() {
  start_from_lane_beginning_ = 0;
}
inline double NotODD::_internal_start_from_lane_beginning() const {
  return start_from_lane_beginning_;
}
inline double NotODD::start_from_lane_beginning() const {
  // @@protoc_insertion_point(field_get:idmap.NotODD.start_from_lane_beginning)
  return _internal_start_from_lane_beginning();
}
inline void NotODD::_internal_set_start_from_lane_beginning(double value) {
  
  start_from_lane_beginning_ = value;
}
inline void NotODD::set_start_from_lane_beginning(double value) {
  _internal_set_start_from_lane_beginning(value);
  // @@protoc_insertion_point(field_set:idmap.NotODD.start_from_lane_beginning)
}

// double dis_to_start = 3;
inline void NotODD::clear_dis_to_start() {
  dis_to_start_ = 0;
}
inline double NotODD::_internal_dis_to_start() const {
  return dis_to_start_;
}
inline double NotODD::dis_to_start() const {
  // @@protoc_insertion_point(field_get:idmap.NotODD.dis_to_start)
  return _internal_dis_to_start();
}
inline void NotODD::_internal_set_dis_to_start(double value) {
  
  dis_to_start_ = value;
}
inline void NotODD::set_dis_to_start(double value) {
  _internal_set_dis_to_start(value);
  // @@protoc_insertion_point(field_set:idmap.NotODD.dis_to_start)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace idmap

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::idmap::MapDataSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idmap::MapDataSource>() {
  return ::idmap::MapDataSource_descriptor();
}
template <> struct is_proto_enum< ::idmap::LineType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idmap::LineType>() {
  return ::idmap::LineType_descriptor();
}
template <> struct is_proto_enum< ::idmap::LineMarkingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idmap::LineMarkingType>() {
  return ::idmap::LineMarkingType_descriptor();
}
template <> struct is_proto_enum< ::idmap::Color> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idmap::Color>() {
  return ::idmap::Color_descriptor();
}
template <> struct is_proto_enum< ::idmap::RoadBoundaryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idmap::RoadBoundaryType>() {
  return ::idmap::RoadBoundaryType_descriptor();
}
template <> struct is_proto_enum< ::idmap::SignType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idmap::SignType>() {
  return ::idmap::SignType_descriptor();
}
template <> struct is_proto_enum< ::idmap::LaneNodeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idmap::LaneNodeType>() {
  return ::idmap::LaneNodeType_descriptor();
}
template <> struct is_proto_enum< ::idmap::GroundMarkType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idmap::GroundMarkType>() {
  return ::idmap::GroundMarkType_descriptor();
}
template <> struct is_proto_enum< ::idmap::GroundMarkPattern> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idmap::GroundMarkPattern>() {
  return ::idmap::GroundMarkPattern_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_idmap_5fcommon_2eproto
